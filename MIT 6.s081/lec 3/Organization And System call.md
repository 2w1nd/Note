# 操作系统组织和系统调用

## 1. 操作系统的隔离性

## 2. 操作系统的防御性

## 3. 硬件对于强隔离的支持

​	硬件对强隔离的支持包括了：`user/kernel`和`虚拟内存`

​	也就是处理器会有两种操作模式：`用户态`和`内核态`

​	当运行在内核态时，CPU可以运行特定权限的指令，当运行在用户态时，CPU只能运行普通权限的指令

​	那么什么是普通指令，什么是特殊指令呢？

​	**普通权限指令就是所有应用程序都允许执行这些指令**。例如将两个寄存器相加的指令ADD，将两个寄存器相减的指令SUB，跳转指令JRC，BRANCH指令等。

​	**特殊指令主要是一些直接操纵硬件的指令和设置保护的指令**。例如设置page table寄存器，关闭时钟中断。在处理器上有多种的状态，操作系统会使用这些状态，但是只能通过特殊权限指令来变更这些状态。

> ​	提问1：如果kernel mode允许一些指令的执行，而user mode不允许一些指令的执行，是谁在检查当前的mode并实际运行这些指令，并且怎么知道当前是不是kernel mode？
>
> ​	处理中有一个flag。当它为1时是user mode，为0时 是kernel mode。当处理器在解析指令时，如果指令是特权指令，并且flag为1，则处理器拒绝执行这条指令。
>
> ​	提问2：设置flag的指令是什么类型的指令？
>
> ​	特权指令，如果用户指令可以设置那就相当于应用程序可以运行各种特殊权限指令了。所以flag是被保护的。
>
> ​	提问3：存在某种用户可以随意地操纵内核吗？
>
> ​	不会。
>
> ​	提问4：BIOS会在操作系统之前还是之后运行？
>
> ​	BIOS会先启动，之后它在启动操作系统，所以BIOS需要是一段可被信任的代码。
>
> ​	提问5：设置处理器中kernel mode的flag是一条特殊权限指令，那么一个用户态的程序要如何让内核执行任何内核指令？因为切换到kernel mode 指令是一条特权指令，对于用户态也就没法修改flag
>
> ​	如果在用户态执行一条特权指令，用户程序会通过系统调用（system call）切换到kernel model。当用户程序执行系统调用，会通过ECALL触发一个软中断（software interrupt），软中断会查询操作系统预先设置的中断向量表，并执行中断向量表中包含的中断处理程序。中断处理程序在内核中，这样就完成了user mode 到 kernel mode的切换，并执行用户程序想要执行的特权指令。

---

​	上述都是通过处理器的用户态和系统态在阐述操作系统是如何支持隔离性的。

​	接下来说说虚拟内存

## 4. User/Kernel model切换

