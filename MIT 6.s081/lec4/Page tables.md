# Page tables

这节课主要包含3部分

- 地址空间
- 虚拟内存的硬件
- XV6中虚拟内存代码

## 1. 地址空间（Address Spaces）

​	创建虚拟内存的一大原因是可以通过它实现隔离性。

​	在RISC-V主板上，内存是由一些DRAM芯片组成，在这些芯片中保存了程序的数据和代码。例如内存中的某一个部分是内核，包括了文本，数据，栈等；如果运行了Shell，则那部分就是shell。。这里说的都是物理内存，它的地址从0开始到某个大的地址结束。结束地址取决于我们的机器现在究竟有多少物理内存。

​	所有的程序都必须存在于物理内存中，否则处理器甚至不能处理程序的指令。

​	但在这种物理内存中，如果多个程序同时运行，很容易破坏隔离性。![image-20211209155051432](image/image-20211209155051432.png)

​	应该有一种方法，让每个程序包括内核在内的都有自己专属的地址空间。该地址空间从0到某个地址结束。

​	所以现在问题是如何在一个物理内存上，创建不同的地址空间。

> ​	问题1：物理内存的数量是有限的，而虚拟地址空间存在最大虚拟内存地址，但是如果有很多个虚拟地址空间，我们在设计的时候需要将最大虚拟内存地址设置的足够小吗？
>
> ​	不需要。虚拟内存可以比物理内存更大，物理内存也可以比虚拟内存更大。我们马上就会看到这里是如何实现的，其实就是通过page table来实现，这里非常灵活。
>
> ​	问题2：如果有太多的进程使用了虚拟内存，有没有可能物理内存耗尽了？
>
> ​	有可能的。如果你有一些大的应用程序，每个程序都有大的page table，并且分配了大量的内存，在某个时间你的内存就耗尽了。

## 2. 页表（Page Table）

​	为了实现在一个物理内存上，创建不同地址空间，我们可以使用页表。

​	页表是硬件中通过处理器和内存管理单元（Memory Management Unit）实现。

​	对于任何一条带有地址的指令，其中地址应该认为是虚拟内存地址，而不是物理地址。例如寄存器a0中是地址`10x1000`，那么这是一个虚拟内存地址。

​	虚拟内存地址会转到内存管理单元，内存管理单元会将虚拟地址转换为物理地址，之后在用这个物理地址来索引物理内存，并从物理内存加载或向物理内存存储数据。![image-20211209161913335](image/image-20211209161913335.png)

​	从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。

​	为了能够完成虚拟内存地址到物理内存地址的翻译，MMU会有一个表单，表单中，一边是虚拟内存地址，另一边是物理内存地址。

​	通常来说，这个表单保存在内存中。所以CPU需要一些寄存器来存放表单在物理内存中的地址。例如某个位置有一个地址关系表单，假设该位置的物理内存地址是`0x10`，那么在`RISC-V`上一个叫做`SATP`的寄存器会保存地址`0x10`.

​	这样，CPU就可以告诉MMU，从哪找到将虚拟内存地址转换成物理内存地址的表单。

> ​	提问1：MMU并不会保存page table，只会从内存中读取page table，然后完成翻译，对吗？
>
> ​	是的

​		基本想法就是**每个应用程序都有自己独立的表单**，并且这个表单定义了应用程序的地址空间。	

​	当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换`SATP`寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。

> ​	提问2：每个进程对应的SATP值是由内核保存的？
>
> ​	是的。内核会写SATP寄存器，这是一条特权指令。所以用户应程序不能通过更新这个寄存器来更换一个地址对应表单，否则就会破坏隔离性。所以，只有运行在kernel mode的代码才可以更新这个寄存器

---

​	通过前面讲述，对页表应该有个大概认识了。

​	那么页表是如何工作的？如果对于每个虚拟地址，在表单中都有一个条目，对于RISC-V，会有$2^{24}$个地址，如果以地址为粒度来管理，表单会非常巨大。

​	所以，实际情况不可能是虚拟内存地址对应`page table`中的一个条目。

​	接下来，会分两部介绍`RISC-V`是如何工作的

​	第一步：**不要为每个地址创建一条表单条目，而是为每个page创建一条表单条目**。（这里第一次读挺蒙的，仔细一想，其实就是将页表拆分为许多page，以前一直以为page=页表QAQ）

​	在RISC-V中，一个page是`4KB`，也就是`4096Bytes`。这个大小非常常见，几乎所有的处理器都是这样。

​	现在，内存地址翻译方式就变了。对于虚拟内存地址，会将它划分为两个部分，`index`和`offset`，`index`用来查找`page`，`offset`对应是一个`page`中的哪个字节

![image-20211209165252306](image/image-20211209165252306.png)

​	











































