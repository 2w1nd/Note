[87. 扰乱字符串](https://leetcode-cn.com/problems/scramble-string/):star::star::star::star::star:

```cpp
class Solution {
public:

    vector<vector<vector<int>>> cache;
    int Y = 1, N = -1;
    string s1, s2;
    bool isScramble(string _s1, string _s2) {
        s1 = _s1, s2 = _s2;
        if (s1 == s2) return true;
        if (s1.size() != s2.size()) return false;
        int n = s1.size();
        // cache表示s1从i开始，s2从j开始 len 位，是否形成扰动字符串
        cache.resize(n, vector<vector<int>>(n, vector<int>(n + 1, 0)));
        return dfs(0, 0, n);
    }

    bool dfs(int i, int j, int len) {
        if (cache[i][j][len] != 0) return cache[i][j][len] == Y;
        string a = s1.substr(i, len), b = s2.substr(j, len);
        if (a == b){
            cache[i][j][len] = Y;
            return true;
        } 
        if (!check(a, b)) {
            cache[i][j][len] = N;
            return false;
        }

        for (int k = 1; k < len; k ++) {
            if (dfs(i, j, k) && dfs(i + k, j + k, len - k)) {
                cache[i][j][len] = Y;
                return true;
            }
            if (dfs(i, len - k + j, k) && dfs(i + k, j, len - k)) {
                cache[i][j][len] = Y;
                return true;
            }
        }
        cache[i][j][len] = N;
        return false;
    }

    bool check(string a, string b) {
        if (a.size() != b.size()) return false;

        vector<int> cnt1(26, 0), cnt2(26, 0);
        for (auto c: s1) {
            cnt1[c - 'a'] ++;
        }
        for (auto c: s2) {
            cnt2[c - 'a'] ++;
        }
        return cnt1 == cnt2;
    }
};
```

#### [375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/):star::star::star:

```cpp
class Solution {
public:

    vector<vector<int>> cache;

    int getMoneyAmount(int n) {
        cache.resize(n + 1, vector<int>(n + 1, 0));
        return dfs(1, n);
    }

    int dfs(int l, int r) {
        if (l >= r) return 0;
        if (cache[l][r] != 0) return cache[l][r];
        int ans = 0x3f3f3f3f;
        for (int x = l; x <= r; x ++) {
            int cnt = max(dfs(l, x - 1), dfs(x + 1, r)) + x;
            ans = min(ans, cnt);
        }
        cache[l][r] = ans;
        return ans;
    }
};
```

#### [403. 青蛙过河:star::star::star:](https://leetcode-cn.com/problems/frog-jump/)

```cpp
class Solution {
public:

    unordered_map<string, bool> cache; // 存储u下标跳k步有没有方案
    unordered_map<int, int> map; // 存储每个石块对应的下标

    bool canCross(vector<int>& stones) {
        int n  = stones.size();
        for (int i = 0; i < n; i ++) {
            map.insert({stones[i], i});
        }
        if (!map.count(1)) return false;
        return dfs(stones, n, 1, 1);
    }

    bool dfs(vector<int> &stones, int n, int u, int k) {
        if (u == n - 1) return true;
        string key = to_string(u) + '_' + to_string(k);
        if (cache.count(key)) return cache[key];
        for (int i = -1; i <= 1; i ++) {
            if (k + i == 0) continue;
            int next = stones[u] + i + k;  // 下一个跳跃点
            if (map.count(next)) {
                bool cur = dfs(stones, n, map[next], k + i);
                cache.insert({key, cur});
                if (cur) return true;
            }
        }
        cache.insert({key, false});
        return false;
    }
};
```

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

```cpp
class Solution {
public:

    unordered_map<string, int> cache; // 表示从u下标,当前计算结果为string，的方案数int

    int findTargetSumWays(vector<int>& nums, int target) {
        return dfs(nums, target, 0, 0);
    }

    int dfs(vector<int> &nums, int target, int u, int cur) {
        string key = to_string(u) + '_' + to_string(cur); 
        if (cache.count(key)) return cache[key];
        if (u == nums.size()) {
            cache.insert({key, cur == target ? 1: 0});
            return cache[key];
        }
        int left = dfs(nums, target, u + 1, cur - nums[u]);
        int right = dfs(nums, target, u + 1, cur + nums[u]);
        cache.insert({key, left + right});
        return cache[key];
    }
};
```

