# 事件

Redis服务器是一个事件驱动程序

- 文件事件：Redis通过套接字与客户端建立链接，而**文件事件就是服务器对套接字操作的抽象**。服务器与客户端的通信会产生一系列相应的文件事件
- 时间事件：对定时操作的抽象

## 1. 文件事件

[Reactor模式详解＋源码实现 - 简书 (jianshu.com)](https://www.jianshu.com/p/188ef8462100)

​	基于Reactor模式创建了自己的网络事件处理器，称为文件事件处理器：

- 使用I/O多路复用同时监听多个套接字，根据套接字的不同选择不同的事件处理器
- 当监听的套接字准备好执行操作时，相应的文件事件就会发生。

文件事件处理器以**单线程方式**运行，但通过使用I/O多路复用程序来监听多个套接字

### 文件事件处理器的构成

​	![image-20211123163345380](https://gitee.com/w1nd1/pic-go-pic/raw/master/blog/image-20211123163345380.png)

​	套接字 -> I/O多路复用 -> 文件事件分派器 -> 事件处理器

- 文件事件是对套接字操作的抽象，每当套接字准备好执行操作时，就会产生一个文件事件，因为一个服务器通常会连接多个套接字，所以多个文件事件会并发的出现
- I/O多路复用程序监听多个套接字，向文件事件分派器传送被“激活”的套接字

I/O多路复用程序会将所有产生事件的套接字都放到一个队列里，通过该队列，有序，同步的到达文件事件分派器

![image-20211123164037556](https://gitee.com/w1nd1/pic-go-pic/raw/master/blog/image-20211123164037556.png)

### I/O多路复用程序的实现

​	通过包装常见的`select`，`epoll`，`evport`，`kqueue`这些I/O多路复用函数库实现

![image-20211123164342376](https://gitee.com/w1nd1/pic-go-pic/raw/master/blog/image-20211123164342376.png)

### 事件的类型

​	有`AE_READABLE`事件和`AE_WRITABLE`事件

- 当套接字可读时，或有可应答套接字出现时，套接字产生`AE_READABLE`事件
- 当套接字可写时，产生`AEWRITABLE`事件

如果一个套接字同时产生这两种事件，那么文件事件分派器会优先处理`AE_READABLE`事件，	再处理`AE_WRITABLE`事件。

### API

| 函数名            | 接受参数                                           | 作用                                                         |
| ----------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| aeCreateFileEvent | 一个套接字描述符、一个事件类型，以及一个事件处理器 | 将给定套接字的给定事件加入到I/O多路复用程序的监听范围之内，并对事件和事件处理器进行关联 |
| aeDeleteFileEvent | 一个套接字描述符和一个监听事件类型作为参数         | 让I/O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联 |
| aeGetFileEvents   | 一个套接字描述符                                   | 返回该套接字正在被监听的事件类型：<br />如果套接字没有任何事件被监听，那么函数返回AE_NONE<br />如果套接字的读事件正在被监听，那么函数返回AE_READABLE。<br />如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE<br />如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE\|AE_WRITABLE。 |
| aeWait            | 一个套接字描述符、一个事件类型和一个毫秒数         | 在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回 |
| aeApiPoll         | 接受一个sys/time.h/struct timeval结构为参数        | 在指定的时间內，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件 |
| aeProcessEvents   |                                                    | 先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。 |
| aeGetApiName      |                                                    | 返回I/O多路复用程序底层所使用的I/O多路复用函数库的名称       |

### 文件事件的处理器

​	`连接应答处理器`，`命令请求处理器`，`命令回复处理器`，`复制处理器`

#### 连接应答处理器

​	acceptTcpHandler函数是Redis的连接应答处理器。

​	对连接服务器监听套接字的客户端进行应答

![image-20211123170633248](https://gitee.com/w1nd1/pic-go-pic/raw/master/blog/image-20211123170633248.png)

#### 命令请求处理器

​	readQueryFromClient函数是Redis的命令请求处理器

​	读入客户端发送的命令请求内容

​	![image-20211123170934642](https://gitee.com/w1nd1/pic-go-pic/raw/master/blog/image-20211123170934642.png)

#### 命令回复处理器

​	sendReplyToClient函数是Redis的命令回复处理器

​	服务器执行命令后得到的命令回复通过套接字返回给客户端

​	![image-20211123184605191](https://gitee.com/w1nd1/pic-go-pic/raw/master/blog/image-20211123184605191.png)

####  一次完整的客户端与服务器连接示例

​	![image-20211123184810994](https://gitee.com/w1nd1/pic-go-pic/raw/master/blog/image-20211123184810994.png)

## 2. 时间事件

分为以下两类：

- 让一段程序在指定的时间之后执行一次。
- 让一段程序每隔指定时间就执行一次。

由以下三个属性组成：

- `id`：服务器为时间事件创建的全局唯一ID。
- `when`：毫秒精度的UNIX时间戳，记录了时间事件的达到时间
- `timeProc`：时间事件处理器，一个函数。当时间事件达到时，调用相应的处理器来处理事件

是定时事件还是周期性事件取决于时间事件处理器的返回值：

- 返回AE_NOMORE，为定时事件；达到一次后被删除，不会再达到
- 非AE_NOMORE的整数值，为周期性事件；服务器会根据事件处理器的返回值，对when进行更新，让该事件在一段时间后再次达到。

### 实现

​	服务器将所有的时间事件都放在一个无序链表中，每当时间事件处理器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。

​	![image-20211123185953131](https://gitee.com/w1nd1/pic-go-pic/raw/master/blog/image-20211123185953131.png)

​	无序不是指ID无序，而是when无序。

​	**无序链表不会影响时间事件处理器的性能**

### API

| 函数名            | 接受参数                                       | 作用                                                         |
| ----------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| aeCreateTimeEvent | 一个毫秒数milliseconds和一个时间事件处理器proc | 将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc |
| aeDeleteFileEvent | 一个时间事件ID                                 | 删除该ID所对应的时间事件                                     |
| processTimeEvents |                                                | 遍历所有已到达的时间事件，并调用这些事件的处理器             |

### 时间事件应用实例：serverCron函数

​	Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期，稳定地运行。这些事由serverCron执行，主要工作如下：

- 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等
- 清理数据库中的过期键值对
- 关闭和清理连接失效的客户端
- 尝试进行AOF或RDB持久化操作
- 如果服务器是主服务器，那么对从服务器进行定期同步
- 如果处于集群模式，对集群进行定期同步和连接测试

2.6版本，默认每秒运行10次

## 3. 事件的调度与运行

​	需要决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们。

​	由aeProcessEvents负责。

```c
def aeProcessEvents() :
// 获取到达时间离当前时间最接近的时间事件
time_event = aeSearchNearestTimer()
// 计算最接近的时间事件距离到达还有多少毫秒
remaind_ms = time_event.when - unix_ts_now()
//如果事件已到达，那么remaind_ms的值可能为负数，将它设定为0
if remaind_ms< 0:
	remaind_ms = 0
//根据remaind_ms的值，创建timeval结构
timeval = create_timeval_with_ms (remaind ms)
//阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定
//如果remaind_ms的值为0，那么aeApiPoll调用之后马上返回，不阻塞aeApiPoll(timeval)
//处理所有已产生的文件事件
processFileEvents()
//处理所有已到达的时间事件
processTimeEvents()
```

​	将该函数置于一个循环中，加上初始化和清理函数，就构成Redis服务器的主函数

![image-20211123192043499](https://gitee.com/w1nd1/pic-go-pic/raw/master/blog/image-20211123192043499.png)

以下是事件的调度和执行规则：

1. aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，如此可以避免服务器对时间事件进行频繁轮询，也可以保证该函数不会阻塞过长时间
2. 时间事件未到达前，服务器一直处理文件事件。
3. 对文件事件和时间事件的处理都是同步，有序，原子地执行的。服务器不会中断事件处理，也不会对事件进行抢占，因此，无论是文件事件的处理器，还是时间事件的处理器，都会尽可能地减少程序的阻塞时间，并在有需要时让出执行权，降低饥饿的可能性
4. 时间事件在文件事件之后执行，事件不会发生抢占，时间事件的处理时间，通常比时间事件设定的达到时间稍晚些







